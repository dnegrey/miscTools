% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modelPerformance.R
\name{modelPerformance}
\alias{modelPerformance}
\title{Evaluate the performance of a model}
\usage{
modelPerformance(y, yhat, y2 = NULL, v = NULL, numBins = 10,
  gainsChartDT.scoreFormatType = "int", gainsChartDT.scoreFormatDigits = 5,
  gainsChartDT.contSumFormatType = "dlr",
  gainsChartDT.contSumFormatDigits = 0,
  gainsChartDT.contAvgFormatType = "dlr",
  gainsChartDT.contAvgFormatDigits = 0, gainsChartDT.KScolor = "#FF3005",
  gainsChartBarGraph.cb = "#009DDC", gainsChartBarGraph.cv = "#77BF30",
  gainsChartBarGraph.xLabel = "Model Quantile",
  gainsChartBarGraph.yLabel = "Mean Outcome",
  gainsChartBarGraph.yType = ifelse(is.null(y2), "pct", "dlr"),
  gainsChartBarGraph.yDigits = ifelse(is.null(y2), 1, 0),
  gainsChartPerfCurve.cb = "#009DDC", gainsChartPerfCurve.cv = "#77BF30",
  gainsChartPerfCurve.cr = "#666666",
  gainsChartPerfCurve.xLabel = "Cumulative Total Percent",
  gainsChartPerfCurve.yLabel = "Cumulative Outcome Percent",
  variableImportanceGraph.x = NULL, variableImportanceGraph.y = NULL,
  variableImportanceGraph.sumYcheck = TRUE,
  variableImportanceGraph.barColor = "rgba(0, 55, 82, 0.6)",
  variableImportanceGraph.lineColor = "#003752",
  variableImportanceGraph.lineWidth = 2)
}
\arguments{
\item{y}{logical, integer or numeric vector (dependent variable)}

\item{yhat}{numeric vector (predicted values of \code{y})}

\item{y2}{logical, integer or numeric vector (other dependent variable for combined models)}

\item{v}{logical, integer or numeric vector of binary values (distinguishes validate (TRUE) vs. build (FALSE) observations)}

\item{numBins}{integer value >= 2; number of desired bins}

\item{gainsChartDT.scoreFormatType}{character string; format type for score field(s); valid values 
are "int", "dlr" and "pct"}

\item{gainsChartDT.scoreFormatDigits}{non-negative integer value; number of decimal places 
for score field(s)}

\item{gainsChartDT.contSumFormatType}{character string; format type for continuous sum field(s); valid values 
are "int", "dlr" and "pct"}

\item{gainsChartDT.contSumFormatDigits}{non-negative integer value; number of decimal places 
for continuous sum field(s)}

\item{gainsChartDT.contAvgFormatType}{character string; format type for continuous average (mean) field(s); valid values 
are "int", "dlr" and "pct"}

\item{gainsChartDT.contAvgFormatDigits}{non-negative integer value; number of decimal places 
for continuous average (mean) field(s)}

\item{gainsChartDT.KScolor}{character string; text color for max KS value (valid color)}

\item{gainsChartBarGraph.cb}{character string; fill color for build bars (valid color)}

\item{gainsChartBarGraph.cv}{character string; fill color for validate bars (valid color)}

\item{gainsChartBarGraph.xLabel}{character string; x-axis label}

\item{gainsChartBarGraph.yLabel}{character string; y-axis label}

\item{gainsChartBarGraph.yType}{character string; y-axis format type; valid 
values are \code{"int"}, \code{"dlr"} and \code{"pct"}}

\item{gainsChartBarGraph.yDigits}{non-negative integer value indicating the number of decimal 
places to show when hovering over the bars}

\item{gainsChartPerfCurve.cb}{character string; line color for build (valid color)}

\item{gainsChartPerfCurve.cv}{character string; line color for validate (valid color)}

\item{gainsChartPerfCurve.cr}{character string; random/reference line color (valid color)}

\item{gainsChartPerfCurve.xLabel}{character string; x-axis label}

\item{gainsChartPerfCurve.yLabel}{character string; y-axis label}

\item{variableImportanceGraph.x}{character vector}

\item{variableImportanceGraph.y}{numeric vector}

\item{variableImportanceGraph.sumYcheck}{logical value; check that \code{sum(y) == 1}?}

\item{variableImportanceGraph.barColor}{character string; fill color for bars (valid color)}

\item{variableImportanceGraph.lineColor}{character string; line color (valid color)}

\item{variableImportanceGraph.lineWidth}{non-negative integer value indicating line width (use 0 to omit)}
}
\value{
A named list with class \code{mt_modelPerformance} containing the following 
objects. Note that when \code{v} is supplied, the data will be split into build 
and validate sets where each set will be evaluated. When \code{v} is not supplied, 
the data is assumed to just be the "build" set.
\itemize{
  \item \code{build}: a list containing the following objects:
  \itemize{
    \item \code{gc}: \code{gainsChart()} object based on build set
    \item \code{gcDT}: \code{gainsChartDT()} object based on build set
    \item \code{gcBG}: \code{gainsChartBarGraph()} object based on build set
    \item \code{gcPC}: \code{gainsChartPerfCurve()} object based on build set
  }
  \item \code{validate}: (only returned when \code{v} is supplied) same type of list as \code{build} but based on validate set
  \item \code{both}: (only returned when \code{v} is supplied) a list containing the following objects:
  \itemize{
    \item \code{gcBG}: \code{gainsChartBarGraph()} object based on build and validate sets
    \item \code{gcPC}: \code{gainsChartPerfCurve()} object based on build and validate sets
  }
  \item \code{varImp}: (only returned when \code{variableImportanceGraph.*} parms are supplied) \code{variableImportanceGraph()} object
}
}
\description{
\code{modelPerformance} is a wrapper function that runs various 
model evaluation techniques and returns the results in a convenient list object. Parameters 
prefaced with a function dot (i.e. \code{gainsChartDT.}) are only applicable to the use 
of that function.
}
\examples{
# pull in sample scored data frame
x <- modelSampleScored
head(x)
# binary target
z <- modelPerformance(
    y = x$TargetFlag,
    yhat = x$pTargetFlag,
    v = x$ValidateFlag
)
class(z)
names(z)
names(z$build)
names(z$validate)
names(z$both)
z$validate$gcDT
z$both$gcBG
z$both$gcPC
# continuous target
z <- modelPerformance(
    y = x[x$TargetFlag, ]$TargetValue,
    yhat = x[x$TargetFlag, ]$pTargetValue,
    v = x[x$TargetFlag, ]$ValidateFlag,
    gainsChartBarGraph.yType = "dlr",
    gainsChartBarGraph.yDigits = 0
)
class(z)
names(z)
names(z$build)
names(z$validate)
names(z$both)
z$validate$gcDT
z$both$gcBG
z$both$gcPC
# combined target (with arbitrary variable importance parms)
z <- modelPerformance(
    y = x$TargetFlag,
    yhat = x$pTargetFlag*x$pTargetValue,
    y2 = x$TargetValue,
    v = x$ValidateFlag,
    variableImportanceGraph.x = c(
        "Days Since Last Transaction",
        "Average Order Value",
        "Signed Up Online",
        "Number of Transactions",
        "Tenure",
        "Multi-Category Flag"
    ),
    variableImportanceGraph.y = c(.18, .4, .04, .25, .12, .01)
)
class(z)
names(z)
names(z$build)
names(z$validate)
names(z$both)
z$validate$gcDT
z$both$gcBG
z$both$gcPC
z$varImp
}
\seealso{
\code{\link{gainsChart}, \link{gainsChartDT}, \link{gainsChartBarGraph}, 
\link{gainsChartPerfCurve}, \link{variableImportanceGraph}}
}
